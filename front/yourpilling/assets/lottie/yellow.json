{"v":"5.9.6","fr":24,"ip":0,"op":120,"w":500,"h":500,"nm":"Smile","ddd":0,"assets":[{"id":"image_0","w":36,"h":15,"u":"","p":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAPCAYAAACMa21tAAAACXBIWXMAAAABAAAAAQBPJcTWAAAAJHpUWHRDcmVhdG9yAAAImXNMyU9KVXBMK0ktUnBNS0tNLikGAEF6Bs5qehXFAAABOElEQVRIicWVsW3DMBBF353URxuEAOU62iAewZ4g6VLGo2QEjeARPILaFASYDaxe5qWwJAhJYDuBEL2KPJD4/w7gp/APOOeKPM+rfrse6mYWT6fTPsZ4HGoyh2BZlmuAlFKlqoWZVUABOOD+yvUW2IUQ6psMrVarysyKiZgDnIgUZvbw9za+sQ0h7PNppSzLtZntOHf3CJBSAkBEMLPx7HQ9EzVQjBPy3tfA09wqv2SbAXjv34CXhc0gIu/qnHPA69JmBlRVN0ubGDCzRlW1WNpITxtC2OvSLiY8A6iZNQsbaekzCPpg9N5HrifqHHwAEYgiEn/6OnIAVd2klA7A3QxiRxEZpn4A6LqumYpeYgxG55zLsqymT+gvtEADICIHOL8IETl2XRdjjPFPLVwyNDE2/sxzi93CJ/F0hO6aqSVOAAAAAElFTkSuQmCC","e":1},{"id":"image_1","w":36,"h":15,"u":"","p":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAPCAYAAACMa21tAAAACXBIWXMAAAABAAAAAQBPJcTWAAAAJHpUWHRDcmVhdG9yAAAImXNMyU9KVXBMK0ktUnBNS0tNLikGAEF6Bs5qehXFAAABLElEQVRIic2UzU3DQBBG3zfOnS1hJCt3U0FSAiWkAyiBEtIBKYESkg7CObG0JZi74+FiCx+AhF/zLrua2Vk9jXZHjHD3ZGYrM0tDLCL2khpJzeFw2PPLaNiUZbkC1sDVBXW7ft1LaiIiS8o/Ia2RzMN3LnqDQTpLyl3XNWa2Bzgej9t3hdw9FUWRuawzP80O2NR1vRkCZmariWQAFsBDWZZbd0+DUDpT9BcsiqK4B7CJRcbcurtbROSpTQbM7MZOp9Mj8Dy1DICZJcs5N8Dd1DIAXdc148F4A2yY7sdhZtcaB/qZtJRURUQCqj61+AOfXV3XS50/98p8Pq8iIkWES3KAiFj26YovdlfSU9u2y5xz8ymhS3B3n81mHhFJUgUfSj9LWrdtu+7f8v/jBWavajjb5gMbAAAAAElFTkSuQmCC","e":1},{"id":"image_2","w":47,"h":47,"u":"","p":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC8AAAAvCAYAAABzJ5OsAAAACXBIWXMAAAABAAAAAQBPJcTWAAAAJHpUWHRDcmVhdG9yAAAImXNMyU9KVXBMK0ktUnBNS0tNLikGAEF6Bs5qehXFAAACx0lEQVRoge2ZT5KiMBTGvxc2s2tLD9CpAvd9g2FOoMvZDXODOYJH4AZN38Aj2DfQ3VQJFJ5A2M2CmFl0sIKCDaIQq/q3CvkDH+HlkbwHPDB0y5tNp9MXKeUIgKvXSykTIkryPF8nSZLe6nmdxHPOR4wxj4hcALOGw3YAVgCWURQtuzz/KvGO47hSSg/Ary4PB5ARkZ/nuX/NF2klnnPOLctaoLvoUzIp5SKOY7/NoMbibdv2APgAntrpaiGGaENE3na7XTfq36STbdsBbj/bdWQAvCbr4aJ4zvnIsqwAzRfjLfkdRVFwqQO71DigcAB4VaZaS+3M92wqtRDRjzAMV5VtVZXqjV/vJ6kVmRCCV7nSM7PhnHN8eBVTeFLme8aZeOXH7+YOr2TmOI57WlkSP51OX2CAnVchpQxO60riD4fDn97UtOfZtu25XnEUzzkfwdBZ1/D0i6N4xph32tNAZmqSAWji1bbWeCzLOpqObvND/Unb4hYFBhy9zKPAiwIDAHV0exS+F4XCbNxhdHTj4q7SdL7ED0WxYJOBdVwFAwAiSgbW0YasKDAAyPO80WndEI5aGQCoU8puMDktIKJVUdYX7Oqsp5msioIuvlPcsCcy/TB+FK+CPFnVCIMI9IuSnycikw7eZwghSvpK4vM892Hu7L8lSZLoFZZ+kabpv8lk8g3mbdQyIcTPNE1LsZuz7UEYhgsi2vSn63OIyD+ddaBmb0NEHswxn/cwDBdVDZXiVXzcu6OgRhDRRggxr2u36hr2+/3f8Xi8A1A7+M5kjLF5HMdJXYda8QCw3+/XQ7wAEW0YY/PPMiSNMiMqgbZEPzHMdyHEvEmCrXFOqocsSUZEft3irKJ1KlN9hQDAc9uxF3gTQiyq3OElrk4iq6Cnh+u/RAYgEEJU+vAmdE7fK3Oa4+OvzKHFVU7IAKzVfnxVl6r54hH4D4fM7svGuoqVAAAAAElFTkSuQmCC","e":1},{"id":"image_3","w":47,"h":47,"u":"","p":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC8AAAAvCAYAAABzJ5OsAAAACXBIWXMAAAABAAAAAQBPJcTWAAAAJHpUWHRDcmVhdG9yAAAImXNMyU9KVXBMK0ktUnBNS0tNLikGAEF6Bs5qehXFAAACx0lEQVRoge2ZT5KiMBTGvxc2s2tLD9CpAvd9g2FOoMvZDXODOYJH4AZN38Aj2DfQ3VQJFJ5A2M2CmFl0sIKCDaIQq/q3CvkDH+HlkbwHPDB0y5tNp9MXKeUIgKvXSykTIkryPF8nSZLe6nmdxHPOR4wxj4hcALOGw3YAVgCWURQtuzz/KvGO47hSSg/Ary4PB5ARkZ/nuX/NF2klnnPOLctaoLvoUzIp5SKOY7/NoMbibdv2APgAntrpaiGGaENE3na7XTfq36STbdsBbj/bdWQAvCbr4aJ4zvnIsqwAzRfjLfkdRVFwqQO71DigcAB4VaZaS+3M92wqtRDRjzAMV5VtVZXqjV/vJ6kVmRCCV7nSM7PhnHN8eBVTeFLme8aZeOXH7+YOr2TmOI57WlkSP51OX2CAnVchpQxO60riD4fDn97UtOfZtu25XnEUzzkfwdBZ1/D0i6N4xph32tNAZmqSAWji1bbWeCzLOpqObvND/Unb4hYFBhy9zKPAiwIDAHV0exS+F4XCbNxhdHTj4q7SdL7ED0WxYJOBdVwFAwAiSgbW0YasKDAAyPO80WndEI5aGQCoU8puMDktIKJVUdYX7Oqsp5msioIuvlPcsCcy/TB+FK+CPFnVCIMI9IuSnycikw7eZwghSvpK4vM892Hu7L8lSZLoFZZ+kabpv8lk8g3mbdQyIcTPNE1LsZuz7UEYhgsi2vSn63OIyD+ddaBmb0NEHswxn/cwDBdVDZXiVXzcu6OgRhDRRggxr2u36hr2+/3f8Xi8A1A7+M5kjLF5HMdJXYda8QCw3+/XQ7wAEW0YY/PPMiSNMiMqgbZEPzHMdyHEvEmCrXFOqocsSUZEft3irKJ1KlN9hQDAc9uxF3gTQiyq3OElrk4iq6Cnh+u/RAYgEEJU+vAmdE7fK3Oa4+OvzKHFVU7IAKzVfnxVl6r54hH4D4fM7svGuoqVAAAAAElFTkSuQmCC","e":1},{"id":"image_4","w":91,"h":30,"u":"","p":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFsAAAAeCAYAAABDo2JGAAAACXBIWXMAAAABAAAAAQBPJcTWAAAAJHpUWHRDcmVhdG9yAAAImXNMyU9KVXBMK0ktUnBNS0tNLikGAEF6Bs5qehXFAAADhklEQVRoge2aP5baSBCHv5IInJnhTb791OJtaG6w3GDJNlx8glW4IT6B5wajvQG+Ac6crRwPzBMnEGQbSN0bIM3TADOA/mCY5y+T1Kou/VR0VxUS9uD7/hAgTdM4juN435ifnI6UD3zfn1hrA+B96fRSRMbz+Xx2Vs+uCKVU13XdkYgoAGttnGXZNI7jVXnck9i+70fW2g+v2Py4WCzCNpy9ZrTWIyDkeYACrIGgrJkLTxH9xwG7o16vt0ySJGrQ16vG87xARO6Bd3suv2NLMwHQWq/YfTMv8TPCAa11CPx5xNB1lmUqjuOV0+/3BxwvNMC91npcwb83gVKq6/t+xHFCA7x3HGcM4FhruxXmvNda31W476rp9/sD13XjA3vbDo7jdAGcNE3jinP/pbWeKqWqvKyrw/O8wBjzL6etAs9w4jiOReR7xft/73Q6s3wpepMopZTWeiYin6vaMMasAJz8OKhqyFr7wRgz8zyvso1LRWs9dl03An6rYWZtjAmhlGfnm959HeeAr1mWja+96lRKKdd1Q+qJXPCUvbnFmSRJol6vtwRGNQwrx3E+3tzc/JckybeaTp4dpVT39vb2bxEJgV8bMPksTZbtqw1FOPk+EFxLmZ8/9wT4pQFza2C8WCym5ZM7Ypcmri14zlcRmVyq6A2LDLB0HGf08PCwU2nvFbvkRFOCwwWJXjSOaFZk2OxZo+0GVMGLYsMmiTfGzKiRW+5MKPLdWnu3ryvWNvnzBGz2pcaeCUBEPs3n88mrYw4ZUUqpTqczPbVqOpIvwLRN4XOBx2wEbjKKC9YiMjrmF3tQbHj62d1xfD/gZPINdWqtjbIsi6qmj77vD40xAxEZAkMajuAtXl02tjlK7IJXerdtsAYiYCUiL7Z1rbUDoAso2oncfayttZPHx8eT+kMniQ2NJ/zXSOXC7WSxC/LG+YTzRPklsDd3PoXKYsN51vJLQEQ+pWl6V3cTryV2ge/7Q2vthLe3tPyTZdmkqV5PI2IX5KKHnG+jaotGRS5oVOyCPGsJuL5Ib0XkglbELihVbJe8pi9FJGxiTT5Eq2IXlD5iCVqqRE9lDUxFJDxnr+YsYpfJ8/Qhm/J5yJlSx7wnMwNmddK3Wj78iEnLlMtrEVENRX5RfUbArE753yQ/XOx99Pv9gbW2a4wZFJ8B5J9clP9YflbGW2sjEVmlaRqdu5t4LP8DCAGdIn/1sEwAAAAASUVORK5CYII=","e":1},{"id":"image_5","w":481,"h":481,"u":"","p":"data:image/png;base64,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","e":1}],"layers":[{"ddd":0,"ind":1,"ty":1,"nm":"Smile Movement","parent":2,"hd":true,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.667,"y":1},"o":{"x":0.333,"y":0},"t":6,"s":[-6.061,-6.061,0],"to":[221.717,-3.283,0],"ti":[0,0,0]},{"i":{"x":0.667,"y":0.667},"o":{"x":0.333,"y":0.333},"t":18,"s":[178.788,-180.303,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.667,"y":1},"o":{"x":0.333,"y":0},"t":41,"s":[178.788,-180.303,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.667,"y":0.667},"o":{"x":0.333,"y":0.333},"t":51,"s":[-121.212,-187.879,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.667,"y":1},"o":{"x":0.333,"y":0},"t":72,"s":[-121.212,-187.879,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.667,"y":1},"o":{"x":0.333,"y":0},"t":76,"s":[-5.682,-192.424,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.667,"y":1},"o":{"x":0.333,"y":0},"t":80,"s":[-6.061,-6.061,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.667,"y":1},"o":{"x":0.333,"y":0},"t":84,"s":[-6.061,-194.318,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.667,"y":1},"o":{"x":0.333,"y":0},"t":88,"s":[-6.061,-6.061,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.667,"y":1},"o":{"x":0.333,"y":0},"t":92,"s":[-6.061,-198.485,0],"to":[0,0,0],"ti":[0,0,0]},{"t":96,"s":[-6.061,-6.061,0]}],"ix":2,"l":2},"a":{"a":0,"k":[37.5,37.5,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":5,"nm":"joystickLimit","np":3,"mn":"ADBE Slider Control","ix":1,"en":1,"ef":[{"ty":0,"nm":"Slider","mn":"ADBE Slider Control-0001","ix":1,"v":{"a":0,"k":200,"ix":1}}]}],"sw":75,"sh":75,"sc":"#ffffff","ip":0,"op":121,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":4,"nm":"Smile Movement Origin","hd":true,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[456,43,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[16.5,16.5,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ty":"rc","d":1,"s":{"a":0,"k":[251.383,200],"ix":2,"x":"var $bm_rt;\nvar temp;\ntemp = $bm_mul(thisComp.layer('Smile Movement')('ADBE Effect Parade')('joystickLimit')('ADBE Slider Control-0001'), 2);\n$bm_rt = [\n    temp,\n    temp\n];"},"p":{"a":0,"k":[0,0],"ix":3},"r":{"a":0,"k":28,"ix":4},"nm":"Rectangle Path 1","mn":"ADBE Vector Shape - Rect","hd":false},{"ty":"st","c":{"a":0,"k":[0.294117629528,0.310726553202,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":7,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"d":[{"n":"d","nm":"dash","v":{"a":0,"k":14,"ix":1}},{"n":"o","nm":"offset","v":{"a":0,"k":0,"ix":7}}],"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":121,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":3,"ty":3,"nm":"Null 1","sr":1,"ks":{"o":{"a":0,"k":0,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[250,250,0],"ix":2,"l":2,"x":"var $bm_rt;\nfunction joystick(inputResult) {\n    var slideR, slideL, slideU, slideD;\n    var easeOverride_right = null;\n    var easeOverride_left = null;\n    var easeOverride_up = null;\n    var easeOverride_down = null;\n    var contrl = thisComp.layer('Smile Movement');\n    var myLimit = contrl('ADBE Effect Parade')('joystickLimit')('ADBE Slider Control-0001');\n    var contrlCurVal = contrl('ADBE Transform Group')('ADBE Position');\n    var resultVal;\n    var key1 = [\n        250,\n        250,\n        0\n    ];\n    var key2 = [\n        250,\n        250,\n        0\n    ];\n    var key3 = [\n        250,\n        250,\n        0\n    ];\n    var key4 = [\n        250,\n        250,\n        0\n    ];\n    var key5 = [\n        250,\n        250,\n        0\n    ];\n    key1 = unArray(key1);\n    key2 = unArray(key2);\n    key3 = unArray(key3);\n    key4 = unArray(key4);\n    key5 = unArray(key5);\n    try {\n        if (!thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB').active) {\n            throw 'inactive';\n        }\n        slideR = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0001');\n        slideL = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0002');\n        slideU = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0003');\n        slideD = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0004');\n    } catch (err) {\n        slideR = 0;\n        slideL = 0;\n        slideU = 0;\n        slideD = 0;\n    }\n    if (easeOverride_right !== null && !isNaN(easeOverride_right)) {\n        slideR = moClamp(easeOverride_right, -100, 100);\n    }\n    if (easeOverride_left !== null && !isNaN(easeOverride_left)) {\n        slideL = moClamp(easeOverride_left, -100, 100);\n    }\n    if (easeOverride_up !== null && !isNaN(easeOverride_up)) {\n        slideU = moClamp(easeOverride_up, -100, 100);\n    }\n    if (easeOverride_down !== null && !isNaN(easeOverride_down)) {\n        slideD = moClamp(easeOverride_down, -100, 100);\n    }\n    var easeResultX, easeResultY;\n    if (contrlCurVal[0] >= 0) {\n        resultVal = linear(contrlCurVal[0], 0, myLimit, key1, key2);\n        if (slideR !== 0) {\n            easeResultX = easeSwitch(contrlCurVal[0], 0, myLimit, key1, key2, slideR);\n            resultVal = linear(Math.abs(slideR), 0, 100, resultVal, easeResultX);\n        }\n    } else {\n        resultVal = linear($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3);\n        if (slideL !== 0) {\n            easeResultX = easeSwitch($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3, slideL);\n            resultVal = linear(Math.abs(slideL), 0, 100, resultVal, easeResultX);\n        }\n    }\n    var resultAdd = 0;\n    if (contrlCurVal[1] <= 0) {\n        resultAdd = $bm_sub(linear($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4), key1);\n        if (slideU !== 0) {\n            easeResultY = $bm_sub(easeSwitch($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4, slideU), key1);\n            resultAdd = linear(Math.abs(slideU), 0, 100, resultAdd, easeResultY);\n        }\n    } else {\n        resultAdd = $bm_sub(linear(contrlCurVal[1], 0, myLimit, key1, key5), key1);\n        if (slideD !== 0) {\n            easeResultY = $bm_sub(easeSwitch(contrlCurVal[1], 0, myLimit, key1, key5, slideD), key1);\n            resultAdd = linear(Math.abs(slideD), 0, 100, resultAdd, easeResultY);\n        }\n    }\n    return $bm_sum($bm_sum(resultVal, resultAdd), $bm_sub(inputResult, key1));\n}\nfunction cosEase(val, min1, max1, input1, input2) {\n    var myCos = [];\n    if ($bm_isInstanceOfArray(input1)) {\n        for (var x = 0; x < input1.length; x++) {\n            myCos.push(getMeCos(val, min1, max1, input1[x], input2[x]));\n        }\n    } else {\n        myCos = getMeCos(val, min1, max1, input1, input2);\n    }\n    return myCos;\n    function getMeCos(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var myCos2 = $bm_sum($bm_sum($bm_mul($bm_neg(c), Math.cos($bm_mul(mapVal, $bm_div(Math.PI, 2)))), c), input1);\n        return myCos2;\n    }\n}\nfunction sinEase(val, min1, max1, input1, input2) {\n    var mySin = [];\n    if ($bm_isInstanceOfArray(input1)) {\n        for (var x = 0; x < input1.length; x++) {\n            mySin.push(getMeSin(val, min1, max1, input1[x], input2[x]));\n        }\n    } else {\n        mySin = getMeSin(val, min1, max1, input1, input2);\n    }\n    return mySin;\n    function getMeSin(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var mySin2 = $bm_sum($bm_mul(c, Math.sin($bm_mul(mapVal, $bm_div(Math.PI, 2)))), input1);\n        return mySin2;\n    }\n}\nfunction easeSwitch(val, min1, max1, input1, input2, morph) {\n    if (morph < 0) {\n        return cosEase(val, min1, max1, input1, input2);\n    } else {\n        return sinEase(val, min1, max1, input1, input2);\n    }\n}\nfunction unArray(inKey) {\n    if (inKey instanceof Array && inKey.length === 1) {\n        return inKey[0];\n    } else {\n        return inKey;\n    }\n}\nfunction moClamp(a, b, c) {\n    if (!(a instanceof Array)) {\n        return Math.max(b, Math.min(c, a));\n    } else {\n        var aryHold = [];\n        for (var x = 0; x < a.length; x++) {\n            aryHold.push(Math.max(b, Math.min(c, a[x])));\n        }\n        return aryHold;\n    }\n}\n$bm_rt = joystick(value);"},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ip":0,"op":121,"st":0,"bm":0},{"ddd":0,"ind":4,"ty":2,"nm":"Eyebrow_L","parent":3,"refId":"image_0","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[-72.894,-129.311,0],"ix":2,"l":2,"x":"var $bm_rt;\nfunction joystick(inputResult) {\n    var slideR, slideL, slideU, slideD;\n    var easeOverride_right = null;\n    var easeOverride_left = null;\n    var easeOverride_up = null;\n    var easeOverride_down = null;\n    var contrl = thisComp.layer('Smile Movement');\n    var myLimit = contrl('ADBE Effect Parade')('joystickLimit')('ADBE Slider Control-0001');\n    var contrlCurVal = contrl('ADBE Transform Group')('ADBE Position');\n    var resultVal;\n    var key1 = [\n        -72.8941040039062,\n        -129.310791015625,\n        0\n    ];\n    var key2 = [\n        -51.3941040039062,\n        -131.310791015625,\n        0\n    ];\n    var key3 = [\n        -113.394104003906,\n        -129.310791015625,\n        0\n    ];\n    var key4 = [\n        -72.8941040039062,\n        -155.810791015625,\n        0\n    ];\n    var key5 = [\n        -72.8941040039062,\n        -85.310791015625,\n        0\n    ];\n    key1 = unArray(key1);\n    key2 = unArray(key2);\n    key3 = unArray(key3);\n    key4 = unArray(key4);\n    key5 = unArray(key5);\n    try {\n        if (!thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB').active) {\n            throw 'inactive';\n        }\n        slideR = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0001');\n        slideL = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0002');\n        slideU = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0003');\n        slideD = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0004');\n    } catch (err) {\n        slideR = 0;\n        slideL = 0;\n        slideU = 0;\n        slideD = 0;\n    }\n    if (easeOverride_right !== null && !isNaN(easeOverride_right)) {\n        slideR = moClamp(easeOverride_right, -100, 100);\n    }\n    if (easeOverride_left !== null && !isNaN(easeOverride_left)) {\n        slideL = moClamp(easeOverride_left, -100, 100);\n    }\n    if (easeOverride_up !== null && !isNaN(easeOverride_up)) {\n        slideU = moClamp(easeOverride_up, -100, 100);\n    }\n    if (easeOverride_down !== null && !isNaN(easeOverride_down)) {\n        slideD = moClamp(easeOverride_down, -100, 100);\n    }\n    var easeResultX, easeResultY;\n    if (contrlCurVal[0] >= 0) {\n        resultVal = linear(contrlCurVal[0], 0, myLimit, key1, key2);\n        if (slideR !== 0) {\n            easeResultX = easeSwitch(contrlCurVal[0], 0, myLimit, key1, key2, slideR);\n            resultVal = linear(Math.abs(slideR), 0, 100, resultVal, easeResultX);\n        }\n    } else {\n        resultVal = linear($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3);\n        if (slideL !== 0) {\n            easeResultX = easeSwitch($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3, slideL);\n            resultVal = linear(Math.abs(slideL), 0, 100, resultVal, easeResultX);\n        }\n    }\n    var resultAdd = 0;\n    if (contrlCurVal[1] <= 0) {\n        resultAdd = $bm_sub(linear($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4), key1);\n        if (slideU !== 0) {\n            easeResultY = $bm_sub(easeSwitch($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4, slideU), key1);\n            resultAdd = linear(Math.abs(slideU), 0, 100, resultAdd, easeResultY);\n        }\n    } else {\n        resultAdd = $bm_sub(linear(contrlCurVal[1], 0, myLimit, key1, key5), key1);\n        if (slideD !== 0) {\n            easeResultY = $bm_sub(easeSwitch(contrlCurVal[1], 0, myLimit, key1, key5, slideD), key1);\n            resultAdd = linear(Math.abs(slideD), 0, 100, resultAdd, easeResultY);\n        }\n    }\n    return $bm_sum($bm_sum(resultVal, resultAdd), $bm_sub(inputResult, key1));\n}\nfunction cosEase(val, min1, max1, input1, input2) {\n    var myCos = [];\n    if ($bm_isInstanceOfArray(input1)) {\n        for (var x = 0; x < input1.length; x++) {\n            myCos.push(getMeCos(val, min1, max1, input1[x], input2[x]));\n        }\n    } else {\n        myCos = getMeCos(val, min1, max1, input1, input2);\n    }\n    return myCos;\n    function getMeCos(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var myCos2 = $bm_sum($bm_sum($bm_mul($bm_neg(c), Math.cos($bm_mul(mapVal, $bm_div(Math.PI, 2)))), c), input1);\n        return myCos2;\n    }\n}\nfunction sinEase(val, min1, max1, input1, input2) {\n    var mySin = [];\n    if ($bm_isInstanceOfArray(input1)) {\n        for (var x = 0; x < input1.length; x++) {\n            mySin.push(getMeSin(val, min1, max1, input1[x], input2[x]));\n        }\n    } else {\n        mySin = getMeSin(val, min1, max1, input1, input2);\n    }\n    return mySin;\n    function getMeSin(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var mySin2 = $bm_sum($bm_mul(c, Math.sin($bm_mul(mapVal, $bm_div(Math.PI, 2)))), input1);\n        return mySin2;\n    }\n}\nfunction easeSwitch(val, min1, max1, input1, input2, morph) {\n    if (morph < 0) {\n        return cosEase(val, min1, max1, input1, input2);\n    } else {\n        return sinEase(val, min1, max1, input1, input2);\n    }\n}\nfunction unArray(inKey) {\n    if (inKey instanceof Array && inKey.length === 1) {\n        return inKey[0];\n    } else {\n        return inKey;\n    }\n}\nfunction moClamp(a, b, c) {\n    if (!(a instanceof Array)) {\n        return Math.max(b, Math.min(c, a));\n    } else {\n        var aryHold = [];\n        for (var x = 0; x < a.length; x++) {\n            aryHold.push(Math.max(b, Math.min(c, a[x])));\n        }\n        return aryHold;\n    }\n}\n$bm_rt = joystick(value);"},"a":{"a":0,"k":[17.961,7.192,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2,"x":"var $bm_rt;\nfunction joystick(inputResult) {\n    var slideR, slideL, slideU, slideD;\n    var easeOverride_right = null;\n    var easeOverride_left = null;\n    var easeOverride_up = null;\n    var easeOverride_down = null;\n    var contrl = thisComp.layer('Smile Movement');\n    var myLimit = contrl('ADBE Effect Parade')('joystickLimit')('ADBE Slider Control-0001');\n    var contrlCurVal = contrl('ADBE Transform Group')('ADBE Position');\n    var resultVal;\n    var key1 = [\n        100,\n        100,\n        100\n    ];\n    var key2 = [\n        100,\n        100,\n        100\n    ];\n    var key3 = [\n        90,\n        90,\n        100\n    ];\n    var key4 = [\n        80,\n        80,\n        100\n    ];\n    var key5 = [\n        120,\n        120,\n        100\n    ];\n    key1 = unArray(key1);\n    key2 = unArray(key2);\n    key3 = unArray(key3);\n    key4 = unArray(key4);\n    key5 = unArray(key5);\n    try {\n        if (!thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB').active) {\n            throw 'inactive';\n        }\n        slideR = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0001');\n        slideL = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0002');\n        slideU = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0003');\n        slideD = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0004');\n    } catch (err) {\n        slideR = 0;\n        slideL = 0;\n        slideU = 0;\n        slideD = 0;\n    }\n    if (easeOverride_right !== null && !isNaN(easeOverride_right)) {\n        slideR = moClamp(easeOverride_right, -100, 100);\n    }\n    if (easeOverride_left !== null && !isNaN(easeOverride_left)) {\n        slideL = moClamp(easeOverride_left, -100, 100);\n    }\n    if (easeOverride_up !== null && !isNaN(easeOverride_up)) {\n        slideU = moClamp(easeOverride_up, -100, 100);\n    }\n    if (easeOverride_down !== null && !isNaN(easeOverride_down)) {\n        slideD = moClamp(easeOverride_down, -100, 100);\n    }\n    var easeResultX, easeResultY;\n    if (contrlCurVal[0] >= 0) {\n        resultVal = linear(contrlCurVal[0], 0, myLimit, key1, key2);\n        if (slideR !== 0) {\n            easeResultX = easeSwitch(contrlCurVal[0], 0, myLimit, key1, key2, slideR);\n            resultVal = linear(Math.abs(slideR), 0, 100, resultVal, easeResultX);\n        }\n    } else {\n        resultVal = linear($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3);\n        if (slideL !== 0) {\n            easeResultX = easeSwitch($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3, slideL);\n            resultVal = linear(Math.abs(slideL), 0, 100, resultVal, easeResultX);\n        }\n    }\n    var resultAdd = 0;\n    if (contrlCurVal[1] <= 0) {\n        resultAdd = $bm_sub(linear($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4), key1);\n        if (slideU !== 0) {\n            easeResultY = $bm_sub(easeSwitch($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4, slideU), key1);\n            resultAdd = linear(Math.abs(slideU), 0, 100, resultAdd, easeResultY);\n        }\n    } else {\n        resultAdd = $bm_sub(linear(contrlCurVal[1], 0, myLimit, key1, key5), key1);\n        if (slideD !== 0) {\n            easeResultY = $bm_sub(easeSwitch(contrlCurVal[1], 0, myLimit, key1, key5, slideD), key1);\n            resultAdd = linear(Math.abs(slideD), 0, 100, resultAdd, easeResultY);\n        }\n    }\n    return $bm_sum($bm_sum(resultVal, resultAdd), $bm_sub(inputResult, key1));\n}\nfunction cosEase(val, min1, max1, input1, input2) {\n    var myCos = [];\n    if ($bm_isInstanceOfArray(input1)) {\n        for (var x = 0; x < input1.length; x++) {\n            myCos.push(getMeCos(val, min1, max1, input1[x], input2[x]));\n        }\n    } else {\n        myCos = getMeCos(val, min1, max1, input1, input2);\n    }\n    return myCos;\n    function getMeCos(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var myCos2 = $bm_sum($bm_sum($bm_mul($bm_neg(c), Math.cos($bm_mul(mapVal, $bm_div(Math.PI, 2)))), c), input1);\n        return myCos2;\n    }\n}\nfunction sinEase(val, min1, max1, input1, input2) {\n    var mySin = [];\n    if ($bm_isInstanceOfArray(input1)) {\n        for (var x = 0; x < input1.length; x++) {\n            mySin.push(getMeSin(val, min1, max1, input1[x], input2[x]));\n        }\n    } else {\n        mySin = getMeSin(val, min1, max1, input1, input2);\n    }\n    return mySin;\n    function getMeSin(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var mySin2 = $bm_sum($bm_mul(c, Math.sin($bm_mul(mapVal, $bm_div(Math.PI, 2)))), input1);\n        return mySin2;\n    }\n}\nfunction easeSwitch(val, min1, max1, input1, input2, morph) {\n    if (morph < 0) {\n        return cosEase(val, min1, max1, input1, input2);\n    } else {\n        return sinEase(val, min1, max1, input1, input2);\n    }\n}\nfunction unArray(inKey) {\n    if (inKey instanceof Array && inKey.length === 1) {\n        return inKey[0];\n    } else {\n        return inKey;\n    }\n}\nfunction moClamp(a, b, c) {\n    if (!(a instanceof Array)) {\n        return Math.max(b, Math.min(c, a));\n    } else {\n        var aryHold = [];\n        for (var x = 0; x < a.length; x++) {\n            aryHold.push(Math.max(b, Math.min(c, a[x])));\n        }\n        return aryHold;\n    }\n}\n$bm_rt = joystick(value);"}},"ao":0,"ip":0,"op":121,"st":0,"bm":0},{"ddd":0,"ind":5,"ty":2,"nm":"Eyebrow_R","parent":3,"refId":"image_1","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[73.602,-129.291,0],"ix":2,"l":2,"x":"var $bm_rt;\nfunction joystick(inputResult) {\n    var slideR, slideL, slideU, slideD;\n    var easeOverride_right = null;\n    var easeOverride_left = null;\n    var easeOverride_up = null;\n    var easeOverride_down = null;\n    var contrl = thisComp.layer('Smile Movement');\n    var myLimit = contrl('ADBE Effect Parade')('joystickLimit')('ADBE Slider Control-0001');\n    var contrlCurVal = contrl('ADBE Transform Group')('ADBE Position');\n    var resultVal;\n    var key1 = [\n        73.6020965576172,\n        -129.29069519043,\n        0\n    ];\n    var key2 = [\n        93.6020965576172,\n        -132.79069519043,\n        0\n    ];\n    var key3 = [\n        29.6020965576172,\n        -129.29069519043,\n        0\n    ];\n    var key4 = [\n        73.6020965576172,\n        -155.79069519043,\n        0\n    ];\n    var key5 = [\n        73.6020965576172,\n        -85.2906951904297,\n        0\n    ];\n    key1 = unArray(key1);\n    key2 = unArray(key2);\n    key3 = unArray(key3);\n    key4 = unArray(key4);\n    key5 = unArray(key5);\n    try {\n        if (!thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB').active) {\n            throw 'inactive';\n        }\n        slideR = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0001');\n        slideL = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0002');\n        slideU = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0003');\n        slideD = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0004');\n    } catch (err) {\n        slideR = 0;\n        slideL = 0;\n        slideU = 0;\n        slideD = 0;\n    }\n    if (easeOverride_right !== null && !isNaN(easeOverride_right)) {\n        slideR = moClamp(easeOverride_right, -100, 100);\n    }\n    if (easeOverride_left !== null && !isNaN(easeOverride_left)) {\n        slideL = moClamp(easeOverride_left, -100, 100);\n    }\n    if (easeOverride_up !== null && !isNaN(easeOverride_up)) {\n        slideU = moClamp(easeOverride_up, -100, 100);\n    }\n    if (easeOverride_down !== null && !isNaN(easeOverride_down)) {\n        slideD = moClamp(easeOverride_down, -100, 100);\n    }\n    var easeResultX, easeResultY;\n    if (contrlCurVal[0] >= 0) {\n        resultVal = linear(contrlCurVal[0], 0, myLimit, key1, key2);\n        if (slideR !== 0) {\n            easeResultX = easeSwitch(contrlCurVal[0], 0, myLimit, key1, key2, slideR);\n            resultVal = linear(Math.abs(slideR), 0, 100, resultVal, easeResultX);\n        }\n    } else {\n        resultVal = linear($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3);\n        if (slideL !== 0) {\n            easeResultX = easeSwitch($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3, slideL);\n            resultVal = linear(Math.abs(slideL), 0, 100, resultVal, easeResultX);\n        }\n    }\n    var resultAdd = 0;\n    if (contrlCurVal[1] <= 0) {\n        resultAdd = $bm_sub(linear($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4), key1);\n        if (slideU !== 0) {\n            easeResultY = $bm_sub(easeSwitch($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4, slideU), key1);\n            resultAdd = linear(Math.abs(slideU), 0, 100, resultAdd, easeResultY);\n        }\n    } else {\n        resultAdd = $bm_sub(linear(contrlCurVal[1], 0, myLimit, key1, key5), key1);\n        if (slideD !== 0) {\n            easeResultY = $bm_sub(easeSwitch(contrlCurVal[1], 0, myLimit, key1, key5, slideD), key1);\n            resultAdd = linear(Math.abs(slideD), 0, 100, resultAdd, easeResultY);\n        }\n    }\n    return $bm_sum($bm_sum(resultVal, resultAdd), $bm_sub(inputResult, key1));\n}\nfunction cosEase(val, min1, max1, input1, input2) {\n    var myCos = [];\n    if ($bm_isInstanceOfArray(input1)) {\n        for (var x = 0; x < input1.length; x++) {\n            myCos.push(getMeCos(val, min1, max1, input1[x], input2[x]));\n        }\n    } else {\n        myCos = getMeCos(val, min1, max1, input1, input2);\n    }\n    return myCos;\n    function getMeCos(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var myCos2 = $bm_sum($bm_sum($bm_mul($bm_neg(c), Math.cos($bm_mul(mapVal, $bm_div(Math.PI, 2)))), c), input1);\n        return myCos2;\n    }\n}\nfunction sinEase(val, min1, max1, input1, input2) {\n    var mySin = [];\n    if ($bm_isInstanceOfArray(input1)) {\n        for (var x = 0; x < input1.length; x++) {\n            mySin.push(getMeSin(val, min1, max1, input1[x], input2[x]));\n        }\n    } else {\n        mySin = getMeSin(val, min1, max1, input1, input2);\n    }\n    return mySin;\n    function getMeSin(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var mySin2 = $bm_sum($bm_mul(c, Math.sin($bm_mul(mapVal, $bm_div(Math.PI, 2)))), input1);\n        return mySin2;\n    }\n}\nfunction easeSwitch(val, min1, max1, input1, input2, morph) {\n    if (morph < 0) {\n        return cosEase(val, min1, max1, input1, input2);\n    } else {\n        return sinEase(val, min1, max1, input1, input2);\n    }\n}\nfunction unArray(inKey) {\n    if (inKey instanceof Array && inKey.length === 1) {\n        return inKey[0];\n    } else {\n        return inKey;\n    }\n}\nfunction moClamp(a, b, c) {\n    if (!(a instanceof Array)) {\n        return Math.max(b, Math.min(c, a));\n    } else {\n        var aryHold = [];\n        for (var x = 0; x < a.length; x++) {\n            aryHold.push(Math.max(b, Math.min(c, a[x])));\n        }\n        return aryHold;\n    }\n}\n$bm_rt = joystick(value);"},"a":{"a":0,"k":[17.955,7.119,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2,"x":"var $bm_rt;\nfunction joystick(inputResult) {\n    var slideR, slideL, slideU, slideD;\n    var easeOverride_right = null;\n    var easeOverride_left = null;\n    var easeOverride_up = null;\n    var easeOverride_down = null;\n    var contrl = thisComp.layer('Smile Movement');\n    var myLimit = contrl('ADBE Effect Parade')('joystickLimit')('ADBE Slider Control-0001');\n    var contrlCurVal = contrl('ADBE Transform Group')('ADBE Position');\n    var resultVal;\n    var key1 = [\n        100,\n        100,\n        100\n    ];\n    var key2 = [\n        90,\n        90,\n        100\n    ];\n    var key3 = [\n        100,\n        100,\n        100\n    ];\n    var key4 = [\n        80,\n        80,\n        100\n    ];\n    var key5 = [\n        120,\n        120,\n        100\n    ];\n    key1 = unArray(key1);\n    key2 = unArray(key2);\n    key3 = unArray(key3);\n    key4 = unArray(key4);\n    key5 = unArray(key5);\n    try {\n        if (!thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB').active) {\n            throw 'inactive';\n        }\n        slideR = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0001');\n        slideL = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0002');\n        slideU = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0003');\n        slideD = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0004');\n    } catch (err) {\n        slideR = 0;\n        slideL = 0;\n        slideU = 0;\n        slideD = 0;\n    }\n    if (easeOverride_right !== null && !isNaN(easeOverride_right)) {\n        slideR = moClamp(easeOverride_right, -100, 100);\n    }\n    if (easeOverride_left !== null && !isNaN(easeOverride_left)) {\n        slideL = moClamp(easeOverride_left, -100, 100);\n    }\n    if (easeOverride_up !== null && !isNaN(easeOverride_up)) {\n        slideU = moClamp(easeOverride_up, -100, 100);\n    }\n    if (easeOverride_down !== null && !isNaN(easeOverride_down)) {\n        slideD = moClamp(easeOverride_down, -100, 100);\n    }\n    var easeResultX, easeResultY;\n    if (contrlCurVal[0] >= 0) {\n        resultVal = linear(contrlCurVal[0], 0, myLimit, key1, key2);\n        if (slideR !== 0) {\n            easeResultX = easeSwitch(contrlCurVal[0], 0, myLimit, key1, key2, slideR);\n            resultVal = linear(Math.abs(slideR), 0, 100, resultVal, easeResultX);\n        }\n    } else {\n        resultVal = linear($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3);\n        if (slideL !== 0) {\n            easeResultX = easeSwitch($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3, slideL);\n            resultVal = linear(Math.abs(slideL), 0, 100, resultVal, easeResultX);\n        }\n    }\n    var resultAdd = 0;\n    if (contrlCurVal[1] <= 0) {\n        resultAdd = $bm_sub(linear($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4), key1);\n        if (slideU !== 0) {\n            easeResultY = $bm_sub(easeSwitch($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4, slideU), key1);\n            resultAdd = linear(Math.abs(slideU), 0, 100, resultAdd, easeResultY);\n        }\n    } else {\n        resultAdd = $bm_sub(linear(contrlCurVal[1], 0, myLimit, key1, key5), key1);\n        if (slideD !== 0) {\n            easeResultY = $bm_sub(easeSwitch(contrlCurVal[1], 0, myLimit, key1, key5, slideD), key1);\n            resultAdd = linear(Math.abs(slideD), 0, 100, resultAdd, easeResultY);\n        }\n    }\n    return $bm_sum($bm_sum(resultVal, resultAdd), $bm_sub(inputResult, key1));\n}\nfunction cosEase(val, min1, max1, input1, input2) {\n    var myCos = [];\n    if ($bm_isInstanceOfArray(input1)) {\n        for (var x = 0; x < input1.length; x++) {\n            myCos.push(getMeCos(val, min1, max1, input1[x], input2[x]));\n        }\n    } else {\n        myCos = getMeCos(val, min1, max1, input1, input2);\n    }\n    return myCos;\n    function getMeCos(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var myCos2 = $bm_sum($bm_sum($bm_mul($bm_neg(c), Math.cos($bm_mul(mapVal, $bm_div(Math.PI, 2)))), c), input1);\n        return myCos2;\n    }\n}\nfunction sinEase(val, min1, max1, input1, input2) {\n    var mySin = [];\n    if ($bm_isInstanceOfArray(input1)) {\n        for (var x = 0; x < input1.length; x++) {\n            mySin.push(getMeSin(val, min1, max1, input1[x], input2[x]));\n        }\n    } else {\n        mySin = getMeSin(val, min1, max1, input1, input2);\n    }\n    return mySin;\n    function getMeSin(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var mySin2 = $bm_sum($bm_mul(c, Math.sin($bm_mul(mapVal, $bm_div(Math.PI, 2)))), input1);\n        return mySin2;\n    }\n}\nfunction easeSwitch(val, min1, max1, input1, input2, morph) {\n    if (morph < 0) {\n        return cosEase(val, min1, max1, input1, input2);\n    } else {\n        return sinEase(val, min1, max1, input1, input2);\n    }\n}\nfunction unArray(inKey) {\n    if (inKey instanceof Array && inKey.length === 1) {\n        return inKey[0];\n    } else {\n        return inKey;\n    }\n}\nfunction moClamp(a, b, c) {\n    if (!(a instanceof Array)) {\n        return Math.max(b, Math.min(c, a));\n    } else {\n        var aryHold = [];\n        for (var x = 0; x < a.length; x++) {\n            aryHold.push(Math.max(b, Math.min(c, a[x])));\n        }\n        return aryHold;\n    }\n}\n$bm_rt = joystick(value);"}},"ao":0,"ip":0,"op":121,"st":0,"bm":0},{"ddd":0,"ind":6,"ty":2,"nm":"Eye_L","parent":3,"refId":"image_2","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[-67.715,-91.089,0],"ix":2,"l":2,"x":"var $bm_rt;\nfunction joystick(inputResult) {\n    var slideR, slideL, slideU, slideD;\n    var easeOverride_right = null;\n    var easeOverride_left = null;\n    var easeOverride_up = null;\n    var easeOverride_down = null;\n    var contrl = thisComp.layer('Smile Movement');\n    var myLimit = contrl('ADBE Effect Parade')('joystickLimit')('ADBE Slider Control-0001');\n    var contrlCurVal = contrl('ADBE Transform Group')('ADBE Position');\n    var resultVal;\n    var key1 = [\n        -67.7151031494141,\n        -91.0892944335938,\n        0\n    ];\n    var key2 = [\n        -38.7151031494141,\n        -91.0892944335938,\n        0\n    ];\n    var key3 = [\n        -109.715103149414,\n        -94.0892944335938,\n        0\n    ];\n    var key4 = [\n        -67.7151031494141,\n        -125.589294433594,\n        0\n    ];\n    var key5 = [\n        -67.7151031494141,\n        -35.0892944335938,\n        0\n    ];\n    key1 = unArray(key1);\n    key2 = unArray(key2);\n    key3 = unArray(key3);\n    key4 = unArray(key4);\n    key5 = unArray(key5);\n    try {\n        if (!thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB').active) {\n            throw 'inactive';\n        }\n        slideR = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0001');\n        slideL = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0002');\n        slideU = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0003');\n        slideD = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0004');\n    } catch (err) {\n        slideR = 0;\n        slideL = 0;\n        slideU = 0;\n        slideD = 0;\n    }\n    if (easeOverride_right !== null && !isNaN(easeOverride_right)) {\n        slideR = moClamp(easeOverride_right, -100, 100);\n    }\n    if (easeOverride_left !== null && !isNaN(easeOverride_left)) {\n        slideL = moClamp(easeOverride_left, -100, 100);\n    }\n    if (easeOverride_up !== null && !isNaN(easeOverride_up)) {\n        slideU = moClamp(easeOverride_up, -100, 100);\n    }\n    if (easeOverride_down !== null && !isNaN(easeOverride_down)) {\n        slideD = moClamp(easeOverride_down, -100, 100);\n    }\n    var easeResultX, easeResultY;\n    if (contrlCurVal[0] >= 0) {\n        resultVal = linear(contrlCurVal[0], 0, myLimit, key1, key2);\n        if (slideR !== 0) {\n            easeResultX = easeSwitch(contrlCurVal[0], 0, myLimit, key1, key2, slideR);\n            resultVal = linear(Math.abs(slideR), 0, 100, resultVal, easeResultX);\n        }\n    } else {\n        resultVal = linear($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3);\n        if (slideL !== 0) {\n            easeResultX = easeSwitch($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3, slideL);\n            resultVal = linear(Math.abs(slideL), 0, 100, resultVal, easeResultX);\n        }\n    }\n    var resultAdd = 0;\n    if (contrlCurVal[1] <= 0) {\n        resultAdd = $bm_sub(linear($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4), key1);\n        if (slideU !== 0) {\n            easeResultY = $bm_sub(easeSwitch($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4, slideU), key1);\n            resultAdd = linear(Math.abs(slideU), 0, 100, resultAdd, easeResultY);\n        }\n    } else {\n        resultAdd = $bm_sub(linear(contrlCurVal[1], 0, myLimit, key1, key5), key1);\n        if (slideD !== 0) {\n            easeResultY = $bm_sub(easeSwitch(contrlCurVal[1], 0, myLimit, key1, key5, slideD), key1);\n            resultAdd = linear(Math.abs(slideD), 0, 100, resultAdd, easeResultY);\n        }\n    }\n    return $bm_sum($bm_sum(resultVal, resultAdd), $bm_sub(inputResult, key1));\n}\nfunction cosEase(val, min1, max1, input1, input2) {\n    var myCos = [];\n    if ($bm_isInstanceOfArray(input1)) {\n        for (var x = 0; x < input1.length; x++) {\n            myCos.push(getMeCos(val, min1, max1, input1[x], input2[x]));\n        }\n    } else {\n        myCos = getMeCos(val, min1, max1, input1, input2);\n    }\n    return myCos;\n    function getMeCos(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var myCos2 = $bm_sum($bm_sum($bm_mul($bm_neg(c), Math.cos($bm_mul(mapVal, $bm_div(Math.PI, 2)))), c), input1);\n        return myCos2;\n    }\n}\nfunction sinEase(val, min1, max1, input1, input2) {\n    var mySin = [];\n    if ($bm_isInstanceOfArray(input1)) {\n        for (var x = 0; x < input1.length; x++) {\n            mySin.push(getMeSin(val, min1, max1, input1[x], input2[x]));\n        }\n    } else {\n        mySin = getMeSin(val, min1, max1, input1, input2);\n    }\n    return mySin;\n    function getMeSin(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var mySin2 = $bm_sum($bm_mul(c, Math.sin($bm_mul(mapVal, $bm_div(Math.PI, 2)))), input1);\n        return mySin2;\n    }\n}\nfunction easeSwitch(val, min1, max1, input1, input2, morph) {\n    if (morph < 0) {\n        return cosEase(val, min1, max1, input1, input2);\n    } else {\n        return sinEase(val, min1, max1, input1, input2);\n    }\n}\nfunction unArray(inKey) {\n    if (inKey instanceof Array && inKey.length === 1) {\n        return inKey[0];\n    } else {\n        return inKey;\n    }\n}\nfunction moClamp(a, b, c) {\n    if (!(a instanceof Array)) {\n        return Math.max(b, Math.min(c, a));\n    } else {\n        var aryHold = [];\n        for (var x = 0; x < a.length; x++) {\n            aryHold.push(Math.max(b, Math.min(c, a[x])));\n        }\n        return aryHold;\n    }\n}\n$bm_rt = joystick(value);"},"a":{"a":0,"k":[23.322,23.322,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ip":0,"op":121,"st":0,"bm":0},{"ddd":0,"ind":7,"ty":2,"nm":"Eye_R","parent":3,"refId":"image_3","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[68.702,-91.089,0],"ix":2,"l":2,"x":"var $bm_rt;\nfunction joystick(inputResult) {\n    var slideR, slideL, slideU, slideD;\n    var easeOverride_right = null;\n    var easeOverride_left = null;\n    var easeOverride_up = null;\n    var easeOverride_down = null;\n    var contrl = thisComp.layer('Smile Movement');\n    var myLimit = contrl('ADBE Effect Parade')('joystickLimit')('ADBE Slider Control-0001');\n    var contrlCurVal = contrl('ADBE Transform Group')('ADBE Position');\n    var resultVal;\n    var key1 = [\n        68.7023010253906,\n        -91.0892944335938,\n        0\n    ];\n    var key2 = [\n        95.7023010253906,\n        -91.0892944335938,\n        0\n    ];\n    var key3 = [\n        23.7023010253906,\n        -91.0892944335938,\n        0\n    ];\n    var key4 = [\n        68.7023010253906,\n        -125.589294433594,\n        0\n    ];\n    var key5 = [\n        68.7023010253906,\n        -35.0892944335938,\n        0\n    ];\n    key1 = unArray(key1);\n    key2 = unArray(key2);\n    key3 = unArray(key3);\n    key4 = unArray(key4);\n    key5 = unArray(key5);\n    try {\n        if (!thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB').active) {\n            throw 'inactive';\n        }\n        slideR = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0001');\n        slideL = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0002');\n        slideU = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0003');\n        slideD = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0004');\n    } catch (err) {\n        slideR = 0;\n        slideL = 0;\n        slideU = 0;\n        slideD = 0;\n    }\n    if (easeOverride_right !== null && !isNaN(easeOverride_right)) {\n        slideR = moClamp(easeOverride_right, -100, 100);\n    }\n    if (easeOverride_left !== null && !isNaN(easeOverride_left)) {\n        slideL = moClamp(easeOverride_left, -100, 100);\n    }\n    if (easeOverride_up !== null && !isNaN(easeOverride_up)) {\n        slideU = moClamp(easeOverride_up, -100, 100);\n    }\n    if (easeOverride_down !== null && !isNaN(easeOverride_down)) {\n        slideD = moClamp(easeOverride_down, -100, 100);\n    }\n    var easeResultX, easeResultY;\n    if (contrlCurVal[0] >= 0) {\n        resultVal = linear(contrlCurVal[0], 0, myLimit, key1, key2);\n        if (slideR !== 0) {\n            easeResultX = easeSwitch(contrlCurVal[0], 0, myLimit, key1, key2, slideR);\n            resultVal = linear(Math.abs(slideR), 0, 100, resultVal, easeResultX);\n        }\n    } else {\n        resultVal = linear($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3);\n        if (slideL !== 0) {\n            easeResultX = easeSwitch($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3, slideL);\n            resultVal = linear(Math.abs(slideL), 0, 100, resultVal, easeResultX);\n        }\n    }\n    var resultAdd = 0;\n    if (contrlCurVal[1] <= 0) {\n        resultAdd = $bm_sub(linear($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4), key1);\n        if (slideU !== 0) {\n            easeResultY = $bm_sub(easeSwitch($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4, slideU), key1);\n            resultAdd = linear(Math.abs(slideU), 0, 100, resultAdd, easeResultY);\n        }\n    } else {\n        resultAdd = $bm_sub(linear(contrlCurVal[1], 0, myLimit, key1, key5), key1);\n        if (slideD !== 0) {\n            easeResultY = $bm_sub(easeSwitch(contrlCurVal[1], 0, myLimit, key1, key5, slideD), key1);\n            resultAdd = linear(Math.abs(slideD), 0, 100, resultAdd, easeResultY);\n        }\n    }\n    return $bm_sum($bm_sum(resultVal, resultAdd), $bm_sub(inputResult, key1));\n}\nfunction cosEase(val, min1, max1, input1, input2) {\n    var myCos = [];\n    if ($bm_isInstanceOfArray(input1)) {\n        for (var x = 0; x < input1.length; x++) {\n            myCos.push(getMeCos(val, min1, max1, input1[x], input2[x]));\n        }\n    } else {\n        myCos = getMeCos(val, min1, max1, input1, input2);\n    }\n    return myCos;\n    function getMeCos(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var myCos2 = $bm_sum($bm_sum($bm_mul($bm_neg(c), Math.cos($bm_mul(mapVal, $bm_div(Math.PI, 2)))), c), input1);\n        return myCos2;\n    }\n}\nfunction sinEase(val, min1, max1, input1, input2) {\n    var mySin = [];\n    if ($bm_isInstanceOfArray(input1)) {\n        for (var x = 0; x < input1.length; x++) {\n            mySin.push(getMeSin(val, min1, max1, input1[x], input2[x]));\n        }\n    } else {\n        mySin = getMeSin(val, min1, max1, input1, input2);\n    }\n    return mySin;\n    function getMeSin(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var mySin2 = $bm_sum($bm_mul(c, Math.sin($bm_mul(mapVal, $bm_div(Math.PI, 2)))), input1);\n        return mySin2;\n    }\n}\nfunction easeSwitch(val, min1, max1, input1, input2, morph) {\n    if (morph < 0) {\n        return cosEase(val, min1, max1, input1, input2);\n    } else {\n        return sinEase(val, min1, max1, input1, input2);\n    }\n}\nfunction unArray(inKey) {\n    if (inKey instanceof Array && inKey.length === 1) {\n        return inKey[0];\n    } else {\n        return inKey;\n    }\n}\nfunction moClamp(a, b, c) {\n    if (!(a instanceof Array)) {\n        return Math.max(b, Math.min(c, a));\n    } else {\n        var aryHold = [];\n        for (var x = 0; x < a.length; x++) {\n            aryHold.push(Math.max(b, Math.min(c, a[x])));\n        }\n        return aryHold;\n    }\n}\n$bm_rt = joystick(value);"},"a":{"a":0,"k":[23.322,23.322,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ip":0,"op":121,"st":0,"bm":0},{"ddd":0,"ind":8,"ty":2,"nm":"Mouth","parent":3,"refId":"image_4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10,"x":"var $bm_rt;\nfunction joystick(inputResult) {\n    var slideR, slideL, slideU, slideD;\n    var easeOverride_right = null;\n    var easeOverride_left = null;\n    var easeOverride_up = null;\n    var easeOverride_down = null;\n    var contrl = thisComp.layer('Smile Movement');\n    var myLimit = contrl('ADBE Effect Parade')('joystickLimit')('ADBE Slider Control-0001');\n    var contrlCurVal = contrl('ADBE Transform Group')('ADBE Position');\n    var resultVal;\n    var key1 = [0];\n    var key2 = [-3];\n    var key3 = [-1];\n    var key4 = [0];\n    var key5 = [0];\n    key1 = unArray(key1);\n    key2 = unArray(key2);\n    key3 = unArray(key3);\n    key4 = unArray(key4);\n    key5 = unArray(key5);\n    try {\n        if (!thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB').active) {\n            throw 'inactive';\n        }\n        slideR = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0001');\n        slideL = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0002');\n        slideU = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0003');\n        slideD = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0004');\n    } catch (err) {\n        slideR = 0;\n        slideL = 0;\n        slideU = 0;\n        slideD = 0;\n    }\n    if (easeOverride_right !== null && !isNaN(easeOverride_right)) {\n        slideR = moClamp(easeOverride_right, -100, 100);\n    }\n    if (easeOverride_left !== null && !isNaN(easeOverride_left)) {\n        slideL = moClamp(easeOverride_left, -100, 100);\n    }\n    if (easeOverride_up !== null && !isNaN(easeOverride_up)) {\n        slideU = moClamp(easeOverride_up, -100, 100);\n    }\n    if (easeOverride_down !== null && !isNaN(easeOverride_down)) {\n        slideD = moClamp(easeOverride_down, -100, 100);\n    }\n    var easeResultX, easeResultY;\n    if (contrlCurVal[0] >= 0) {\n        resultVal = linear(contrlCurVal[0], 0, myLimit, key1, key2);\n        if (slideR !== 0) {\n            easeResultX = easeSwitch(contrlCurVal[0], 0, myLimit, key1, key2, slideR);\n            resultVal = linear(Math.abs(slideR), 0, 100, resultVal, easeResultX);\n        }\n    } else {\n        resultVal = linear($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3);\n        if (slideL !== 0) {\n            easeResultX = easeSwitch($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3, slideL);\n            resultVal = linear(Math.abs(slideL), 0, 100, resultVal, easeResultX);\n        }\n    }\n    var resultAdd = 0;\n    if (contrlCurVal[1] <= 0) {\n        resultAdd = $bm_sub(linear($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4), key1);\n        if (slideU !== 0) {\n            easeResultY = $bm_sub(easeSwitch($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4, slideU), key1);\n            resultAdd = linear(Math.abs(slideU), 0, 100, resultAdd, easeResultY);\n        }\n    } else {\n        resultAdd = $bm_sub(linear(contrlCurVal[1], 0, myLimit, key1, key5), key1);\n        if (slideD !== 0) {\n            easeResultY = $bm_sub(easeSwitch(contrlCurVal[1], 0, myLimit, key1, key5, slideD), key1);\n            resultAdd = linear(Math.abs(slideD), 0, 100, resultAdd, easeResultY);\n        }\n    }\n    return $bm_sum($bm_sum(resultVal, resultAdd), $bm_sub(inputResult, key1));\n}\nfunction cosEase(val, min1, max1, input1, input2) {\n    var myCos = [];\n    if ($bm_isInstanceOfArray(input1)) {\n        for (var x = 0; x < input1.length; x++) {\n            myCos.push(getMeCos(val, min1, max1, input1[x], input2[x]));\n        }\n    } else {\n        myCos = getMeCos(val, min1, max1, input1, input2);\n    }\n    return myCos;\n    function getMeCos(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var myCos2 = $bm_sum($bm_sum($bm_mul($bm_neg(c), Math.cos($bm_mul(mapVal, $bm_div(Math.PI, 2)))), c), input1);\n        return myCos2;\n    }\n}\nfunction sinEase(val, min1, max1, input1, input2) {\n    var mySin = [];\n    if ($bm_isInstanceOfArray(input1)) {\n        for (var x = 0; x < input1.length; x++) {\n            mySin.push(getMeSin(val, min1, max1, input1[x], input2[x]));\n        }\n    } else {\n        mySin = getMeSin(val, min1, max1, input1, input2);\n    }\n    return mySin;\n    function getMeSin(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var mySin2 = $bm_sum($bm_mul(c, Math.sin($bm_mul(mapVal, $bm_div(Math.PI, 2)))), input1);\n        return mySin2;\n    }\n}\nfunction easeSwitch(val, min1, max1, input1, input2, morph) {\n    if (morph < 0) {\n        return cosEase(val, min1, max1, input1, input2);\n    } else {\n        return sinEase(val, min1, max1, input1, input2);\n    }\n}\nfunction unArray(inKey) {\n    if (inKey instanceof Array && inKey.length === 1) {\n        return inKey[0];\n    } else {\n        return inKey;\n    }\n}\nfunction moClamp(a, b, c) {\n    if (!(a instanceof Array)) {\n        return Math.max(b, Math.min(c, a));\n    } else {\n        var aryHold = [];\n        for (var x = 0; x < a.length; x++) {\n            aryHold.push(Math.max(b, Math.min(c, a[x])));\n        }\n        return aryHold;\n    }\n}\n$bm_rt = joystick(value);"},"p":{"a":0,"k":[-0.064,-29.191,0],"ix":2,"l":2,"x":"var $bm_rt;\nfunction joystick(inputResult) {\n    var slideR, slideL, slideU, slideD;\n    var easeOverride_right = null;\n    var easeOverride_left = null;\n    var easeOverride_up = null;\n    var easeOverride_down = null;\n    var contrl = thisComp.layer('Smile Movement');\n    var myLimit = contrl('ADBE Effect Parade')('joystickLimit')('ADBE Slider Control-0001');\n    var contrlCurVal = contrl('ADBE Transform Group')('ADBE Position');\n    var resultVal;\n    var key1 = [\n        -0.06399536132812,\n        -29.1914978027344,\n        0\n    ];\n    var key2 = [\n        37.9360046386719,\n        -29.1914978027344,\n        0\n    ];\n    var key3 = [\n        -51.0639953613281,\n        -29.1914978027344,\n        0\n    ];\n    var key4 = [\n        -0.06399536132812,\n        -63.1914978027344,\n        0\n    ];\n    var key5 = [\n        -0.06399536132812,\n        20.8085021972656,\n        0\n    ];\n    key1 = unArray(key1);\n    key2 = unArray(key2);\n    key3 = unArray(key3);\n    key4 = unArray(key4);\n    key5 = unArray(key5);\n    try {\n        if (!thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB').active) {\n            throw 'inactive';\n        }\n        slideR = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0001');\n        slideL = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0002');\n        slideU = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0003');\n        slideD = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0004');\n    } catch (err) {\n        slideR = 0;\n        slideL = 0;\n        slideU = 0;\n        slideD = 0;\n    }\n    if (easeOverride_right !== null && !isNaN(easeOverride_right)) {\n        slideR = moClamp(easeOverride_right, -100, 100);\n    }\n    if (easeOverride_left !== null && !isNaN(easeOverride_left)) {\n        slideL = moClamp(easeOverride_left, -100, 100);\n    }\n    if (easeOverride_up !== null && !isNaN(easeOverride_up)) {\n        slideU = moClamp(easeOverride_up, -100, 100);\n    }\n    if (easeOverride_down !== null && !isNaN(easeOverride_down)) {\n        slideD = moClamp(easeOverride_down, -100, 100);\n    }\n    var easeResultX, easeResultY;\n    if (contrlCurVal[0] >= 0) {\n        resultVal = linear(contrlCurVal[0], 0, myLimit, key1, key2);\n        if (slideR !== 0) {\n            easeResultX = easeSwitch(contrlCurVal[0], 0, myLimit, key1, key2, slideR);\n            resultVal = linear(Math.abs(slideR), 0, 100, resultVal, easeResultX);\n        }\n    } else {\n        resultVal = linear($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3);\n        if (slideL !== 0) {\n            easeResultX = easeSwitch($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3, slideL);\n            resultVal = linear(Math.abs(slideL), 0, 100, resultVal, easeResultX);\n        }\n    }\n    var resultAdd = 0;\n    if (contrlCurVal[1] <= 0) {\n        resultAdd = $bm_sub(linear($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4), key1);\n        if (slideU !== 0) {\n            easeResultY = $bm_sub(easeSwitch($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4, slideU), key1);\n            resultAdd = linear(Math.abs(slideU), 0, 100, resultAdd, easeResultY);\n        }\n    } else {\n        resultAdd = $bm_sub(linear(contrlCurVal[1], 0, myLimit, key1, key5), key1);\n        if (slideD !== 0) {\n            easeResultY = $bm_sub(easeSwitch(contrlCurVal[1], 0, myLimit, key1, key5, slideD), key1);\n            resultAdd = linear(Math.abs(slideD), 0, 100, resultAdd, easeResultY);\n        }\n    }\n    return $bm_sum($bm_sum(resultVal, resultAdd), $bm_sub(inputResult, key1));\n}\nfunction cosEase(val, min1, max1, input1, input2) {\n    var myCos = [];\n    if ($bm_isInstanceOfArray(input1)) {\n        for (var x = 0; x < input1.length; x++) {\n            myCos.push(getMeCos(val, min1, max1, input1[x], input2[x]));\n        }\n    } else {\n        myCos = getMeCos(val, min1, max1, input1, input2);\n    }\n    return myCos;\n    function getMeCos(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var myCos2 = $bm_sum($bm_sum($bm_mul($bm_neg(c), Math.cos($bm_mul(mapVal, $bm_div(Math.PI, 2)))), c), input1);\n        return myCos2;\n    }\n}\nfunction sinEase(val, min1, max1, input1, input2) {\n    var mySin = [];\n    if ($bm_isInstanceOfArray(input1)) {\n        for (var x = 0; x < input1.length; x++) {\n            mySin.push(getMeSin(val, min1, max1, input1[x], input2[x]));\n        }\n    } else {\n        mySin = getMeSin(val, min1, max1, input1, input2);\n    }\n    return mySin;\n    function getMeSin(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var mySin2 = $bm_sum($bm_mul(c, Math.sin($bm_mul(mapVal, $bm_div(Math.PI, 2)))), input1);\n        return mySin2;\n    }\n}\nfunction easeSwitch(val, min1, max1, input1, input2, morph) {\n    if (morph < 0) {\n        return cosEase(val, min1, max1, input1, input2);\n    } else {\n        return sinEase(val, min1, max1, input1, input2);\n    }\n}\nfunction unArray(inKey) {\n    if (inKey instanceof Array && inKey.length === 1) {\n        return inKey[0];\n    } else {\n        return inKey;\n    }\n}\nfunction moClamp(a, b, c) {\n    if (!(a instanceof Array)) {\n        return Math.max(b, Math.min(c, a));\n    } else {\n        var aryHold = [];\n        for (var x = 0; x < a.length; x++) {\n            aryHold.push(Math.max(b, Math.min(c, a[x])));\n        }\n        return aryHold;\n    }\n}\n$bm_rt = joystick(value);"},"a":{"a":0,"k":[45.178,14.893,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2,"x":"var $bm_rt;\nfunction joystick(inputResult) {\n    var slideR, slideL, slideU, slideD;\n    var easeOverride_right = null;\n    var easeOverride_left = null;\n    var easeOverride_up = null;\n    var easeOverride_down = null;\n    var contrl = thisComp.layer('Smile Movement');\n    var myLimit = contrl('ADBE Effect Parade')('joystickLimit')('ADBE Slider Control-0001');\n    var contrlCurVal = contrl('ADBE Transform Group')('ADBE Position');\n    var resultVal;\n    var key1 = [\n        100,\n        100,\n        100\n    ];\n    var key2 = [\n        100,\n        100,\n        100\n    ];\n    var key3 = [\n        100,\n        100,\n        100\n    ];\n    var key4 = [\n        110,\n        110,\n        100\n    ];\n    var key5 = [\n        85,\n        85,\n        100\n    ];\n    key1 = unArray(key1);\n    key2 = unArray(key2);\n    key3 = unArray(key3);\n    key4 = unArray(key4);\n    key5 = unArray(key5);\n    try {\n        if (!thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB').active) {\n            throw 'inactive';\n        }\n        slideR = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0001');\n        slideL = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0002');\n        slideU = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0003');\n        slideD = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0004');\n    } catch (err) {\n        slideR = 0;\n        slideL = 0;\n        slideU = 0;\n        slideD = 0;\n    }\n    if (easeOverride_right !== null && !isNaN(easeOverride_right)) {\n        slideR = moClamp(easeOverride_right, -100, 100);\n    }\n    if (easeOverride_left !== null && !isNaN(easeOverride_left)) {\n        slideL = moClamp(easeOverride_left, -100, 100);\n    }\n    if (easeOverride_up !== null && !isNaN(easeOverride_up)) {\n        slideU = moClamp(easeOverride_up, -100, 100);\n    }\n    if (easeOverride_down !== null && !isNaN(easeOverride_down)) {\n        slideD = moClamp(easeOverride_down, -100, 100);\n    }\n    var easeResultX, easeResultY;\n    if (contrlCurVal[0] >= 0) {\n        resultVal = linear(contrlCurVal[0], 0, myLimit, key1, key2);\n        if (slideR !== 0) {\n            easeResultX = easeSwitch(contrlCurVal[0], 0, myLimit, key1, key2, slideR);\n            resultVal = linear(Math.abs(slideR), 0, 100, resultVal, easeResultX);\n        }\n    } else {\n        resultVal = linear($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3);\n        if (slideL !== 0) {\n            easeResultX = easeSwitch($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3, slideL);\n            resultVal = linear(Math.abs(slideL), 0, 100, resultVal, easeResultX);\n        }\n    }\n    var resultAdd = 0;\n    if (contrlCurVal[1] <= 0) {\n        resultAdd = $bm_sub(linear($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4), key1);\n        if (slideU !== 0) {\n            easeResultY = $bm_sub(easeSwitch($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4, slideU), key1);\n            resultAdd = linear(Math.abs(slideU), 0, 100, resultAdd, easeResultY);\n        }\n    } else {\n        resultAdd = $bm_sub(linear(contrlCurVal[1], 0, myLimit, key1, key5), key1);\n        if (slideD !== 0) {\n            easeResultY = $bm_sub(easeSwitch(contrlCurVal[1], 0, myLimit, key1, key5, slideD), key1);\n            resultAdd = linear(Math.abs(slideD), 0, 100, resultAdd, easeResultY);\n        }\n    }\n    return $bm_sum($bm_sum(resultVal, resultAdd), $bm_sub(inputResult, key1));\n}\nfunction cosEase(val, min1, max1, input1, input2) {\n    var myCos = [];\n    if ($bm_isInstanceOfArray(input1)) {\n        for (var x = 0; x < input1.length; x++) {\n            myCos.push(getMeCos(val, min1, max1, input1[x], input2[x]));\n        }\n    } else {\n        myCos = getMeCos(val, min1, max1, input1, input2);\n    }\n    return myCos;\n    function getMeCos(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var myCos2 = $bm_sum($bm_sum($bm_mul($bm_neg(c), Math.cos($bm_mul(mapVal, $bm_div(Math.PI, 2)))), c), input1);\n        return myCos2;\n    }\n}\nfunction sinEase(val, min1, max1, input1, input2) {\n    var mySin = [];\n    if ($bm_isInstanceOfArray(input1)) {\n        for (var x = 0; x < input1.length; x++) {\n            mySin.push(getMeSin(val, min1, max1, input1[x], input2[x]));\n        }\n    } else {\n        mySin = getMeSin(val, min1, max1, input1, input2);\n    }\n    return mySin;\n    function getMeSin(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var mySin2 = $bm_sum($bm_mul(c, Math.sin($bm_mul(mapVal, $bm_div(Math.PI, 2)))), input1);\n        return mySin2;\n    }\n}\nfunction easeSwitch(val, min1, max1, input1, input2, morph) {\n    if (morph < 0) {\n        return cosEase(val, min1, max1, input1, input2);\n    } else {\n        return sinEase(val, min1, max1, input1, input2);\n    }\n}\nfunction unArray(inKey) {\n    if (inKey instanceof Array && inKey.length === 1) {\n        return inKey[0];\n    } else {\n        return inKey;\n    }\n}\nfunction moClamp(a, b, c) {\n    if (!(a instanceof Array)) {\n        return Math.max(b, Math.min(c, a));\n    } else {\n        var aryHold = [];\n        for (var x = 0; x < a.length; x++) {\n            aryHold.push(Math.max(b, Math.min(c, a[x])));\n        }\n        return aryHold;\n    }\n}\n$bm_rt = joystick(value);"}},"ao":0,"ip":0,"op":121,"st":0,"bm":0},{"ddd":0,"ind":9,"ty":4,"nm":"Shadow/Smile Outlines","sr":1,"ks":{"o":{"a":0,"k":30,"ix":11},"r":{"a":0,"k":0,"ix":10,"x":"var $bm_rt;\nfunction joystick(inputResult) {\n    var slideR, slideL, slideU, slideD;\n    var easeOverride_right = null;\n    var easeOverride_left = null;\n    var easeOverride_up = null;\n    var easeOverride_down = null;\n    var contrl = thisComp.layer('Smile Movement');\n    var myLimit = contrl('ADBE Effect Parade')('joystickLimit')('ADBE Slider Control-0001');\n    var contrlCurVal = contrl('ADBE Transform Group')('ADBE Position');\n    var resultVal;\n    var key1 = [0];\n    var key2 = [6];\n    var key3 = [-6];\n    var key4 = [0];\n    var key5 = [0];\n    key1 = unArray(key1);\n    key2 = unArray(key2);\n    key3 = unArray(key3);\n    key4 = unArray(key4);\n    key5 = unArray(key5);\n    try {\n        if (!thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB').active) {\n            throw 'inactive';\n        }\n        slideR = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0001');\n        slideL = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0002');\n        slideU = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0003');\n        slideD = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0004');\n    } catch (err) {\n        slideR = 0;\n        slideL = 0;\n        slideU = 0;\n        slideD = 0;\n    }\n    if (easeOverride_right !== null && !isNaN(easeOverride_right)) {\n        slideR = moClamp(easeOverride_right, -100, 100);\n    }\n    if (easeOverride_left !== null && !isNaN(easeOverride_left)) {\n        slideL = moClamp(easeOverride_left, -100, 100);\n    }\n    if (easeOverride_up !== null && !isNaN(easeOverride_up)) {\n        slideU = moClamp(easeOverride_up, -100, 100);\n    }\n    if (easeOverride_down !== null && !isNaN(easeOverride_down)) {\n        slideD = moClamp(easeOverride_down, -100, 100);\n    }\n    var easeResultX, easeResultY;\n    if (contrlCurVal[0] >= 0) {\n        resultVal = linear(contrlCurVal[0], 0, myLimit, key1, key2);\n        if (slideR !== 0) {\n            easeResultX = easeSwitch(contrlCurVal[0], 0, myLimit, key1, key2, slideR);\n            resultVal = linear(Math.abs(slideR), 0, 100, resultVal, easeResultX);\n        }\n    } else {\n        resultVal = linear($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3);\n        if (slideL !== 0) {\n            easeResultX = easeSwitch($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3, slideL);\n            resultVal = linear(Math.abs(slideL), 0, 100, resultVal, easeResultX);\n        }\n    }\n    var resultAdd = 0;\n    if (contrlCurVal[1] <= 0) {\n        resultAdd = $bm_sub(linear($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4), key1);\n        if (slideU !== 0) {\n            easeResultY = $bm_sub(easeSwitch($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4, slideU), key1);\n            resultAdd = linear(Math.abs(slideU), 0, 100, resultAdd, easeResultY);\n        }\n    } else {\n        resultAdd = $bm_sub(linear(contrlCurVal[1], 0, myLimit, key1, key5), key1);\n        if (slideD !== 0) {\n            easeResultY = $bm_sub(easeSwitch(contrlCurVal[1], 0, myLimit, key1, key5, slideD), key1);\n            resultAdd = linear(Math.abs(slideD), 0, 100, resultAdd, easeResultY);\n        }\n    }\n    return $bm_sum($bm_sum(resultVal, resultAdd), $bm_sub(inputResult, key1));\n}\nfunction cosEase(val, min1, max1, input1, input2) {\n    var myCos = [];\n    if ($bm_isInstanceOfArray(input1)) {\n        for (var x = 0; x < input1.length; x++) {\n            myCos.push(getMeCos(val, min1, max1, input1[x], input2[x]));\n        }\n    } else {\n        myCos = getMeCos(val, min1, max1, input1, input2);\n    }\n    return myCos;\n    function getMeCos(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var myCos2 = $bm_sum($bm_sum($bm_mul($bm_neg(c), Math.cos($bm_mul(mapVal, $bm_div(Math.PI, 2)))), c), input1);\n        return myCos2;\n    }\n}\nfunction sinEase(val, min1, max1, input1, input2) {\n    var mySin = [];\n    if ($bm_isInstanceOfArray(input1)) {\n        for (var x = 0; x < input1.length; x++) {\n            mySin.push(getMeSin(val, min1, max1, input1[x], input2[x]));\n        }\n    } else {\n        mySin = getMeSin(val, min1, max1, input1, input2);\n    }\n    return mySin;\n    function getMeSin(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var mySin2 = $bm_sum($bm_mul(c, Math.sin($bm_mul(mapVal, $bm_div(Math.PI, 2)))), input1);\n        return mySin2;\n    }\n}\nfunction easeSwitch(val, min1, max1, input1, input2, morph) {\n    if (morph < 0) {\n        return cosEase(val, min1, max1, input1, input2);\n    } else {\n        return sinEase(val, min1, max1, input1, input2);\n    }\n}\nfunction unArray(inKey) {\n    if (inKey instanceof Array && inKey.length === 1) {\n        return inKey[0];\n    } else {\n        return inKey;\n    }\n}\nfunction moClamp(a, b, c) {\n    if (!(a instanceof Array)) {\n        return Math.max(b, Math.min(c, a));\n    } else {\n        var aryHold = [];\n        for (var x = 0; x < a.length; x++) {\n            aryHold.push(Math.max(b, Math.min(c, a[x])));\n        }\n        return aryHold;\n    }\n}\n$bm_rt = joystick(value);"},"p":{"a":0,"k":[254.5,421,0],"ix":2,"l":2,"x":"var $bm_rt;\nfunction joystick(inputResult) {\n    var slideR, slideL, slideU, slideD;\n    var easeOverride_right = null;\n    var easeOverride_left = null;\n    var easeOverride_up = null;\n    var easeOverride_down = null;\n    var contrl = thisComp.layer('Smile Movement');\n    var myLimit = contrl('ADBE Effect Parade')('joystickLimit')('ADBE Slider Control-0001');\n    var contrlCurVal = contrl('ADBE Transform Group')('ADBE Position');\n    var resultVal;\n    var key1 = [\n        254.5,\n        421,\n        0\n    ];\n    var key2 = [\n        237,\n        420.5,\n        0\n    ];\n    var key3 = [\n        272.25,\n        420,\n        0\n    ];\n    var key4 = [\n        254.5,\n        421,\n        0\n    ];\n    var key5 = [\n        254.5,\n        421,\n        0\n    ];\n    key1 = unArray(key1);\n    key2 = unArray(key2);\n    key3 = unArray(key3);\n    key4 = unArray(key4);\n    key5 = unArray(key5);\n    try {\n        if (!thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB').active) {\n            throw 'inactive';\n        }\n        slideR = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0001');\n        slideL = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0002');\n        slideU = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0003');\n        slideD = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0004');\n    } catch (err) {\n        slideR = 0;\n        slideL = 0;\n        slideU = 0;\n        slideD = 0;\n    }\n    if (easeOverride_right !== null && !isNaN(easeOverride_right)) {\n        slideR = moClamp(easeOverride_right, -100, 100);\n    }\n    if (easeOverride_left !== null && !isNaN(easeOverride_left)) {\n        slideL = moClamp(easeOverride_left, -100, 100);\n    }\n    if (easeOverride_up !== null && !isNaN(easeOverride_up)) {\n        slideU = moClamp(easeOverride_up, -100, 100);\n    }\n    if (easeOverride_down !== null && !isNaN(easeOverride_down)) {\n        slideD = moClamp(easeOverride_down, -100, 100);\n    }\n    var easeResultX, easeResultY;\n    if (contrlCurVal[0] >= 0) {\n        resultVal = linear(contrlCurVal[0], 0, myLimit, key1, key2);\n        if (slideR !== 0) {\n            easeResultX = easeSwitch(contrlCurVal[0], 0, myLimit, key1, key2, slideR);\n            resultVal = linear(Math.abs(slideR), 0, 100, resultVal, easeResultX);\n        }\n    } else {\n        resultVal = linear($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3);\n        if (slideL !== 0) {\n            easeResultX = easeSwitch($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3, slideL);\n            resultVal = linear(Math.abs(slideL), 0, 100, resultVal, easeResultX);\n        }\n    }\n    var resultAdd = 0;\n    if (contrlCurVal[1] <= 0) {\n        resultAdd = $bm_sub(linear($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4), key1);\n        if (slideU !== 0) {\n            easeResultY = $bm_sub(easeSwitch($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4, slideU), key1);\n            resultAdd = linear(Math.abs(slideU), 0, 100, resultAdd, easeResultY);\n        }\n    } else {\n        resultAdd = $bm_sub(linear(contrlCurVal[1], 0, myLimit, key1, key5), key1);\n        if (slideD !== 0) {\n            easeResultY = $bm_sub(easeSwitch(contrlCurVal[1], 0, myLimit, key1, key5, slideD), key1);\n            resultAdd = linear(Math.abs(slideD), 0, 100, resultAdd, easeResultY);\n        }\n    }\n    return $bm_sum($bm_sum(resultVal, resultAdd), $bm_sub(inputResult, key1));\n}\nfunction cosEase(val, min1, max1, input1, input2) {\n    var myCos = [];\n    if ($bm_isInstanceOfArray(input1)) {\n        for (var x = 0; x < input1.length; x++) {\n            myCos.push(getMeCos(val, min1, max1, input1[x], input2[x]));\n        }\n    } else {\n        myCos = getMeCos(val, min1, max1, input1, input2);\n    }\n    return myCos;\n    function getMeCos(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var myCos2 = $bm_sum($bm_sum($bm_mul($bm_neg(c), Math.cos($bm_mul(mapVal, $bm_div(Math.PI, 2)))), c), input1);\n        return myCos2;\n    }\n}\nfunction sinEase(val, min1, max1, input1, input2) {\n    var mySin = [];\n    if ($bm_isInstanceOfArray(input1)) {\n        for (var x = 0; x < input1.length; x++) {\n            mySin.push(getMeSin(val, min1, max1, input1[x], input2[x]));\n        }\n    } else {\n        mySin = getMeSin(val, min1, max1, input1, input2);\n    }\n    return mySin;\n    function getMeSin(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var mySin2 = $bm_sum($bm_mul(c, Math.sin($bm_mul(mapVal, $bm_div(Math.PI, 2)))), input1);\n        return mySin2;\n    }\n}\nfunction easeSwitch(val, min1, max1, input1, input2, morph) {\n    if (morph < 0) {\n        return cosEase(val, min1, max1, input1, input2);\n    } else {\n        return sinEase(val, min1, max1, input1, input2);\n    }\n}\nfunction unArray(inKey) {\n    if (inKey instanceof Array && inKey.length === 1) {\n        return inKey[0];\n    } else {\n        return inKey;\n    }\n}\nfunction moClamp(a, b, c) {\n    if (!(a instanceof Array)) {\n        return Math.max(b, Math.min(c, a));\n    } else {\n        var aryHold = [];\n        for (var x = 0; x < a.length; x++) {\n            aryHold.push(Math.max(b, Math.min(c, a[x])));\n        }\n        return aryHold;\n    }\n}\n$bm_rt = joystick(value);"},"a":{"a":0,"k":[203.5,56.5,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[81.311,0],[49.164,51.175],[-85.681,0],[-42.463,67.552]],"o":[[-81.311,0],[42.464,67.552],[85.68,0],[-49.164,51.175]],"v":[[0,27.359],[-203.325,-56.23],[0,56.23],[203.324,-56.23]],"c":true},"ix":2,"x":"var $bm_rt;\nif (numKeys > 0 || typeof createPath === 'undefined') {\n    $bm_rt = value;\n} else {\n    var contrl = thisComp.layer('Smile Movement');\n    var myLimit = contrl('ADBE Effect Parade')('joystickLimit')('ADBE Slider Control-0001').value;\n    var contrlCurVal = contrl('ADBE Transform Group')('ADBE Position').value;\n    var key1 = {\n        closed: true,\n        vertices: [\n            [\n                0,\n                27.4\n            ],\n            [\n                -203.3,\n                -56.2\n            ],\n            [\n                0,\n                56.2\n            ],\n            [\n                203.3,\n                -56.2\n            ]\n        ],\n        inTangents: [\n            [\n                81.3,\n                0\n            ],\n            [\n                49.2,\n                51.2\n            ],\n            [\n                -85.7,\n                0\n            ],\n            [\n                -42.5,\n                67.6\n            ]\n        ],\n        outTangents: [\n            [\n                -81.3,\n                0\n            ],\n            [\n                42.5,\n                67.6\n            ],\n            [\n                85.7,\n                0\n            ],\n            [\n                -49.2,\n                51.2\n            ]\n        ],\n        featherSegLocs: [],\n        featherRelSegLocs: [],\n        featherRadii: [],\n        featherInterps: [],\n        featherTensions: [],\n        featherTypes: [],\n        featherRelCornerAngles: []\n    };\n    var key2 = {\n        closed: true,\n        vertices: [\n            [null],\n            [null],\n            [null],\n            [null]\n        ],\n        inTangents: [\n            [null],\n            [null],\n            [null],\n            [null]\n        ],\n        outTangents: [\n            [null],\n            [null],\n            [null],\n            [null]\n        ],\n        featherSegLocs: [],\n        featherRelSegLocs: [],\n        featherRadii: [],\n        featherInterps: [],\n        featherTensions: [],\n        featherTypes: [],\n        featherRelCornerAngles: []\n    };\n    var key3 = {\n        closed: true,\n        vertices: [\n            [null],\n            [null],\n            [null],\n            [null]\n        ],\n        inTangents: [\n            [null],\n            [null],\n            [null],\n            [null]\n        ],\n        outTangents: [\n            [null],\n            [null],\n            [null],\n            [null]\n        ],\n        featherSegLocs: [],\n        featherRelSegLocs: [],\n        featherRadii: [],\n        featherInterps: [],\n        featherTensions: [],\n        featherTypes: [],\n        featherRelCornerAngles: []\n    };\n    var key4 = {\n        closed: true,\n        vertices: [\n            [\n                -1,\n                12.4\n            ],\n            [null],\n            [null],\n            [null]\n        ],\n        inTangents: [\n            [null],\n            [null],\n            [null],\n            [null]\n        ],\n        outTangents: [\n            [null],\n            [null],\n            [null],\n            [null]\n        ],\n        featherSegLocs: [],\n        featherRelSegLocs: [],\n        featherRadii: [],\n        featherInterps: [],\n        featherTensions: [],\n        featherTypes: [],\n        featherRelCornerAngles: []\n    };\n    var key5 = {\n        closed: true,\n        vertices: [\n            [\n                -0.5,\n                38.4\n            ],\n            [null],\n            [null],\n            [null]\n        ],\n        inTangents: [\n            [null],\n            [null],\n            [null],\n            [null]\n        ],\n        outTangents: [\n            [null],\n            [null],\n            [null],\n            [null]\n        ],\n        featherSegLocs: [],\n        featherRelSegLocs: [],\n        featherRadii: [],\n        featherInterps: [],\n        featherTensions: [],\n        featherTypes: [],\n        featherRelCornerAngles: []\n    };\n    var rotoBezier = false;\n    var bias = {};\n    try {\n        if (!thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB').active) {\n            throw 'inactive';\n        }\n        bias.slideR = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0001').value;\n        bias.slideL = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0002').value;\n        bias.slideU = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0003').value;\n        bias.slideD = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0004').value;\n    } catch (err) {\n        bias.slideR = 0;\n        bias.slideL = 0;\n        bias.slideU = 0;\n        bias.slideD = 0;\n    }\n    function joystick(key1, key2, key3, key4, key5, bias, contrl) {\n        var resultVal;\n        key1 = unArray(key1);\n        key2 = unArray(key2);\n        key3 = unArray(key3);\n        key4 = unArray(key4);\n        key5 = unArray(key5);\n        var easeResultX, easeResultY;\n        if (contrlCurVal[0] >= 0) {\n            if (key2 === null) {\n                resultVal = key1;\n            } else {\n                resultVal = linear(contrlCurVal[0], 0, myLimit, key1, key2);\n                if (bias.slideR !== 0) {\n                    easeResultX = easeSwitch(contrlCurVal[0], 0, myLimit, key1, key2, bias.slideR);\n                    resultVal = linear(Math.abs(bias.slideR), 0, 100, resultVal, easeResultX);\n                }\n            }\n        } else {\n            if (key3 === null) {\n                resultVal = key1;\n            } else {\n                resultVal = linear($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3);\n                if (bias.slideL !== 0) {\n                    easeResultX = easeSwitch($bm_sub(0, contrlCurVal[0]), 0, myLimit, key1, key3, bias.slideL);\n                    resultVal = linear(Math.abs(bias.slideL), 0, 100, resultVal, easeResultX);\n                }\n            }\n        }\n        var resultAdd = 0;\n        if (contrlCurVal[1] <= 0) {\n            if (key4 === null) {\n                resultAdd = [\n                    0,\n                    0\n                ];\n            } else {\n                resultAdd = $bm_sub(linear($bm_sub(0, contrlCurVal[1]), 0, myLimit, key1, key4), key1);\n                if (bias.slideU !== 0) {\n                    easeResultY = $bm_sub(easeSwitch($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4, bias.slideU), key1);\n                    resultAdd = linear(Math.abs(bias.slideU), 0, 100, resultAdd, easeResultY);\n                }\n            }\n        } else {\n            if (key5 === null) {\n                resultAdd = [\n                    0,\n                    0\n                ];\n            } else {\n                resultAdd = $bm_sub(linear(contrlCurVal[1], 0, myLimit, key1, key5), key1);\n                if (bias.slideD !== 0) {\n                    easeResultY = $bm_sub(easeSwitch(contrlCurVal[1], 0, myLimit, key1, key5, bias.slideD), key1);\n                    resultAdd = linear(Math.abs(bias.slideD), 0, 100, resultAdd, easeResultY);\n                }\n            }\n        }\n        return $bm_sum(resultVal, resultAdd);\n    }\n    function cosEase(val, min1, max1, input1, input2) {\n        var myCos = [];\n        if ($bm_isInstanceOfArray(input1)) {\n            for (var x = 0; x < input1.length; x++) {\n                myCos.push(getMeCos(val, min1, max1, input1[x], input2[x]));\n            }\n        } else {\n            myCos = getMeCos(val, min1, max1, input1, input2);\n        }\n        return myCos;\n        function getMeCos(val, min1, max1, input1, input2) {\n            var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n            var c = $bm_sub(input2, input1);\n            var myCos2 = $bm_sum($bm_sum($bm_mul($bm_neg(c), Math.cos($bm_mul(mapVal, $bm_div(Math.PI, 2)))), c), input1);\n            return myCos2;\n        }\n    }\n    function sinEase(val, min1, max1, input1, input2) {\n        var mySin = [];\n        if ($bm_isInstanceOfArray(input1)) {\n            for (var x = 0; x < input1.length; x++) {\n                mySin.push(getMeSin(val, min1, max1, input1[x], input2[x]));\n            }\n        } else {\n            mySin = getMeSin(val, min1, max1, input1, input2);\n        }\n        return mySin;\n    }\n    function getMeSin(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var mySin2 = $bm_sum($bm_mul(c, Math.sin($bm_mul(mapVal, $bm_div(Math.PI, 2)))), input1);\n        return mySin2;\n    }\n    function easeSwitch(val, min1, max1, input1, input2, morph) {\n        if (morph < 0) {\n            return cosEase(val, min1, max1, input1, input2);\n        } else {\n            return sinEase(val, min1, max1, input1, input2);\n        }\n    }\n    function unArray(inKey) {\n        if (inKey instanceof Array && inKey.length === 1) {\n            return inKey[0];\n        } else {\n            return inKey;\n        }\n    }\n    function moClamp(a, b, c) {\n        if (!(a instanceof Array)) {\n            return Math.max(b, Math.min(c, a));\n        } else {\n            var aryHold = [];\n            for (var x = 0; x < a.length; x++) {\n                aryHold.push(Math.max(b, Math.min(c, a[x])));\n            }\n            return aryHold;\n        }\n    }\n    var myPoints = [];\n    var myInTangents = [];\n    var myOutTangents = [];\n    var k1vl = key1.vertices.length;\n    var i = 0;\n    for (i = 0; i < k1vl; i++) {\n        myPoints.push(joystick(key1.vertices[i], key2.vertices[i], key3.vertices[i], key4.vertices[i], key5.vertices[i], bias, contrl));\n        myInTangents.push(joystick(key1.inTangents[i], key2.inTangents[i], key3.inTangents[i], key4.inTangents[i], key5.inTangents[i], bias, contrl));\n        myOutTangents.push(joystick(key1.outTangents[i], key2.outTangents[i], key3.outTangents[i], key4.outTangents[i], key5.outTangents[i], bias, contrl));\n    }\n    $bm_rt = createPath(myPoints, myInTangents, myOutTangents, key1.closed);\n}"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.113725497676,0.113725497676,0.105882360421,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[198.78,69.221],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":4,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":121,"st":0,"ct":1,"bm":3},{"ddd":0,"ind":10,"ty":2,"nm":"Face","refId":"image_5","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[250,250,0],"ix":2,"l":2,"x":"var $bm_rt;\nfunction joystick(inputResult) {\n    var slideR, slideL, slideU, slideD;\n    var easeOverride_right = null;\n    var easeOverride_left = null;\n    var easeOverride_up = null;\n    var easeOverride_down = null;\n    var contrl = thisComp.layer('Smile Movement');\n    var myLimit = contrl('ADBE Effect Parade')('joystickLimit')('ADBE Slider Control-0001');\n    var contrlCurVal = contrl('ADBE Transform Group')('ADBE Position');\n    var resultVal;\n    var key1 = [\n        250,\n        250,\n        0\n    ];\n    var key2 = [\n        250,\n        250,\n        0\n    ];\n    var key3 = [\n        250,\n        250,\n        0\n    ];\n    var key4 = [\n        250,\n        250,\n        0\n    ];\n    var key5 = [\n        250,\n        250,\n        0\n    ];\n    key1 = unArray(key1);\n    key2 = unArray(key2);\n    key3 = unArray(key3);\n    key4 = unArray(key4);\n    key5 = unArray(key5);\n    try {\n        if (!thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB').active) {\n            throw 'inactive';\n        }\n        slideR = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0001');\n        slideL = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0002');\n        slideU = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0003');\n        slideD = thisLayer('ADBE Effect Parade')('Pseudo/1k48264d77gIB')('Pseudo/1k48264d77gIB-0004');\n    } catch (err) {\n        slideR = 0;\n        slideL = 0;\n        slideU = 0;\n        slideD = 0;\n    }\n    if (easeOverride_right !== null && !isNaN(easeOverride_right)) {\n        slideR = moClamp(easeOverride_right, -100, 100);\n    }\n    if (easeOverride_left !== null && !isNaN(easeOverride_left)) {\n        slideL = moClamp(easeOverride_left, -100, 100);\n    }\n    if (easeOverride_up !== null && !isNaN(easeOverride_up)) {\n        slideU = moClamp(easeOverride_up, -100, 100);\n    }\n    if (easeOverride_down !== null && !isNaN(easeOverride_down)) {\n        slideD = moClamp(easeOverride_down, -100, 100);\n    }\n    var easeResultX, easeResultY;\n    if (contrlCurVal[0] >= 0) {\n        resultVal = linear(contrlCurVal[0], 0, myLimit, key1, key2);\n        if (slideR !== 0) {\n            easeResultX = easeSwitch(contrlCurVal[0], 0, myLimit, key1, key2, slideR);\n            resultVal = linear(Math.abs(slideR), 0, 100, resultVal, easeResultX);\n        }\n    } else {\n        resultVal = linear($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3);\n        if (slideL !== 0) {\n            easeResultX = easeSwitch($bm_neg(contrlCurVal[0]), 0, myLimit, key1, key3, slideL);\n            resultVal = linear(Math.abs(slideL), 0, 100, resultVal, easeResultX);\n        }\n    }\n    var resultAdd = 0;\n    if (contrlCurVal[1] <= 0) {\n        resultAdd = $bm_sub(linear($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4), key1);\n        if (slideU !== 0) {\n            easeResultY = $bm_sub(easeSwitch($bm_neg(contrlCurVal[1]), 0, myLimit, key1, key4, slideU), key1);\n            resultAdd = linear(Math.abs(slideU), 0, 100, resultAdd, easeResultY);\n        }\n    } else {\n        resultAdd = $bm_sub(linear(contrlCurVal[1], 0, myLimit, key1, key5), key1);\n        if (slideD !== 0) {\n            easeResultY = $bm_sub(easeSwitch(contrlCurVal[1], 0, myLimit, key1, key5, slideD), key1);\n            resultAdd = linear(Math.abs(slideD), 0, 100, resultAdd, easeResultY);\n        }\n    }\n    return $bm_sum($bm_sum(resultVal, resultAdd), $bm_sub(inputResult, key1));\n}\nfunction cosEase(val, min1, max1, input1, input2) {\n    var myCos = [];\n    if ($bm_isInstanceOfArray(input1)) {\n        for (var x = 0; x < input1.length; x++) {\n            myCos.push(getMeCos(val, min1, max1, input1[x], input2[x]));\n        }\n    } else {\n        myCos = getMeCos(val, min1, max1, input1, input2);\n    }\n    return myCos;\n    function getMeCos(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var myCos2 = $bm_sum($bm_sum($bm_mul($bm_neg(c), Math.cos($bm_mul(mapVal, $bm_div(Math.PI, 2)))), c), input1);\n        return myCos2;\n    }\n}\nfunction sinEase(val, min1, max1, input1, input2) {\n    var mySin = [];\n    if ($bm_isInstanceOfArray(input1)) {\n        for (var x = 0; x < input1.length; x++) {\n            mySin.push(getMeSin(val, min1, max1, input1[x], input2[x]));\n        }\n    } else {\n        mySin = getMeSin(val, min1, max1, input1, input2);\n    }\n    return mySin;\n    function getMeSin(val, min1, max1, input1, input2) {\n        var mapVal = moClamp($bm_div(val, $bm_sub(max1, min1)), 0, 1);\n        var c = $bm_sub(input2, input1);\n        var mySin2 = $bm_sum($bm_mul(c, Math.sin($bm_mul(mapVal, $bm_div(Math.PI, 2)))), input1);\n        return mySin2;\n    }\n}\nfunction easeSwitch(val, min1, max1, input1, input2, morph) {\n    if (morph < 0) {\n        return cosEase(val, min1, max1, input1, input2);\n    } else {\n        return sinEase(val, min1, max1, input1, input2);\n    }\n}\nfunction unArray(inKey) {\n    if (inKey instanceof Array && inKey.length === 1) {\n        return inKey[0];\n    } else {\n        return inKey;\n    }\n}\nfunction moClamp(a, b, c) {\n    if (!(a instanceof Array)) {\n        return Math.max(b, Math.min(c, a));\n    } else {\n        var aryHold = [];\n        for (var x = 0; x < a.length; x++) {\n            aryHold.push(Math.max(b, Math.min(c, a[x])));\n        }\n        return aryHold;\n    }\n}\n$bm_rt = joystick(value);"},"a":{"a":0,"k":[240.25,240.25,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ip":0,"op":121,"st":0,"bm":0}],"markers":[]}